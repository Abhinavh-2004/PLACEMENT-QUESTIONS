# Goldman Sachs

**Year:** 2025
**Type:** Internship  

---

## Online Assessment Overview  
- It was an unproctored test for `2 hours` consisting of multiple components.
- It had `3 DSA` questions, `15 MCQ` questions, and `1 behavioral` question
- *DSA questions* were of **medium** level difficulty covering topics like bit manipulation, greedy algorithms, and sorting
- *MCQ questions* covered **C, C++, Java, OOP concepts, and SQL**
- *Behavioral question* assessed soft skills and cultural fit

---

## Question 1: *Minimizing Product-Sum Difference*  
**Description:**  
- You are given N organic substances where each substance has:
  - `G[i]` â†’ Growth Boost (used in product calculation)
  - `T[i]` â†’ Toxicity (used in sum calculation)
- Choose at least one substance such that `|Product of G - Sum of T|` is minimized
- Need to find the minimum possible absolute difference between the product of selected growth values and sum of selected toxicity values

**Examples & Constraints:**  
- You must select at least one substance
- For each valid subset of substances:
  - Calculate product of all G[i] values in the subset
  - Calculate sum of all T[i] values in the subset  
  - Find absolute difference between product and sum
- Return the minimum such difference across all possible subsets

**Approach:**
1. **Subset Formation with Bitmasking**
   * Each subset of substances can either include or exclude each element.
   * With `N` substances, there are `2^N` subsets.
   * We can represent these subsets using a bitmask (binary representation).

2. **Calculation for Each Subset**
   * For every subset generated by the bitmask, compute:
      * **Product of Growth Boost values** (`G[i]`)
      * **Sum of Toxicity values** (`T[i]`)
   * Find their absolute difference.

3. **Minimization**
   * Keep a running minimum difference (`minDiff`).
   * Update it whenever a smaller difference is found.

4. **Complexity**
   * Time Complexity: `O(N * 2^N)` (each subset requires up to `N` operations).
   * Space Complexity: `O(1)` (only counters used).

ðŸ‘‰ Works best when `N â‰¤ 20`.  
ðŸ‘‰ For larger `N`, you can discuss advanced techniques like **meet-in-the-middle** as an optimization idea.

**Tags:** *bit manipulation, brute force, subset enumeration*

**Similar Questions:**  
- Subset sum problems
- Bitmask DP problems

---

## Question 2: *Employee Mentorship System*  

**Description:**  
- Each employee has two attributes:
  - `A` â†’ Technical Skill Level
  - `B` â†’ Project Exposure Level
- Two types of operations:
  - `E A B` â†’ A new employee joins with skill A and exposure B
  - `Q i` â†’ The i-th employee (1-indexed, based on join order) requests a mentor

**Mentorship Rules:**
- A mentor must have `A â‰¥ requestor's A` and `B â‰¥ requestor's B`
- Among valid mentors, choose based on priority:
  1. **Smallest difference in B** (exposure level)
  2. If tied, **smallest difference in A** (skill level)
- Each mentor can help **only one employee**
- Output the mentor's ID (1-indexed) or "NE" if no mentor is found

**Examples & Constraints:**  
- Employees are numbered based on their join order (1-indexed)
- Once a mentor is assigned, they cannot mentor another employee
- Self-mentoring is not allowed (employee cannot mentor themselves)

**Approach:**
1. **Employee Tracking**
   * Use a list/array to store every employee's skill (`A`) and exposure (`B`) when they join.

2. **Query Handling** (`Q i`)
   * For the `i`-th employee, check all potential mentors (other employees who are not already used as mentors).
   * Apply the **mentorship conditions**:
      * Mentor must have `A â‰¥ A[i]` and `B â‰¥ B[i]`.

3. **Choosing the Best Mentor**
   * Among valid mentors, apply the **priority rules**:
      * Smallest difference in exposure `B`.
      * If tie â†’ smallest difference in skill `A`.
   * If no valid mentor exists, return `"NE"`.

4. **Mark Mentors as Used**
   * Once a mentor is assigned, mark them so they cannot mentor again.

5. **Complexity**
   * Each query may scan all employees â†’ `O(N^2)` in the worst case.
   * Suitable for small to medium `N`.

ðŸ‘‰ The problem is a **simulation + greedy selection** type.  
ðŸ‘‰ In blogs, you can also mention that for **very large N**, advanced data structures (like balanced BSTs or priority queues with multi-key sorting) could optimize mentor lookups.

**Tags:** *greedy algorithm, simulation, priority matching*

**Similar Questions:**  
- Assignment problems
- Matching algorithms
- Priority-based selection

---

## Question 3: *Custom Sorting by Factor Count*  

**Description:**  
- Given an array of N integers, sort them according to specific rules:
  1. **Primary criteria:** Descending order of number of factors
  2. **Secondary criteria:** If two numbers have the same number of factors, sort them by descending value

**Examples & Constraints:**  
- Count factors efficiently for each number
- Number with more factors comes first
- Among numbers with same factor count, larger number comes first

**Approach:**
1. **Factor Counting**
   * For each number, count its factors efficiently.
   * Use the `âˆšn` trick:
      * For every `i` from `1` to `âˆšnum`, if `i` divides `num`, then both `i` and `num/i` are factors.

2. **Pairing with Original Number**
   * Store `(factorCount, number)` for each element.

3. **Sorting with Custom Comparator**
   * Sort by:
      * **Primary:** Descending factor count.
      * **Secondary (tie-breaker):** Descending number value.

4. **Output**
   * Extract and print numbers in this new sorted order.

5. **Complexity**
   * Factor counting: `O(NâˆšM)` where `M` is max number.
   * Sorting: `O(N log N)`.
   * Overall efficient for moderate `N` and values.

ðŸ‘‰ This problem blends **number theory (factorization)** and **custom sorting with comparators**.  
ðŸ‘‰ Great for explaining how to design your own sorting criteria in C++ with `sort()`.

**Tags:** *sorting, number theory, factor counting*

**Similar Questions:**  
- Custom comparator problems
- Number theory problems
- Sorting with multiple criteria

---

## MCQ Topics Covered

The 15 MCQ questions covered the following areas:

### C/C++ Fundamentals
- Pointers and memory management
- Data types and type conversion
- Operators and precedence
- Control structures

### Java Basics
- Object-oriented programming concepts
- Inheritance and polymorphism
- Exception handling
- Collections framework basics

### OOP Concepts
- Encapsulation, Inheritance, Polymorphism, Abstraction
- Class and object relationships
- Method overriding vs overloading
- Access modifiers

### SQL
- Basic queries (SELECT, WHERE, ORDER BY)
- Joins (INNER, LEFT, RIGHT)
- Aggregate functions
- GROUP BY and HAVING clauses

---

## Behavioral Question

The behavioral component typically assessed:
- **Teamwork and collaboration**
- **Problem-solving approach**
- **Leadership potential**
- **Cultural fit with Goldman Sachs values**
- **Communication skills**

Common behavioral question themes:
- "Describe a challenging project you worked on"
- "How do you handle tight deadlines?"
- "Give an example of when you had to work in a team"
- "What motivates you in your work?"

---

## Preparation Tips

### For DSA Questions:
- Practice bit manipulation and subset generation
- Focus on greedy algorithms and priority-based matching
- Work on custom sorting problems with multiple criteria
- Time complexity analysis is crucial

### For MCQs:
- Review basic C/C++ concepts thoroughly
- Understand OOP principles with practical examples
- Practice SQL queries, especially joins and aggregations
- Java basics including collections and exception handling

---

## Final Thoughts

The Goldman Sachs online assessment strikes a good balance between technical depth and breadth. The DSA questions test algorithmic thinking without being overly complex, while the MCQs ensure solid fundamentals across multiple programming languages and concepts. The behavioral component adds an important dimension to evaluate cultural fit.

**Key Success Factors:**
- Strong foundation in algorithms and data structures
- Multi-language programming knowledge (C/C++, Java)
- Clear communication in behavioral responses
- Time management during the 2-hour assessment

> ***ANYONE CAN CONTRIBUTE! LET'S BUILD A COMMUNITY!!***